=================================Task_1========================================
Формулировка:
        Оценить размер множества потенциальных состояний программы. Ответ обосновать.
Ответ:
        Так как мы считаем количество потенциальных состояний, следовательно, мы
    учитывем все строчки программы(fLines, gLines), даже те, которые никогда не будут выполняться.
        Для подсчета состояний также нужно знать какие значения (потенциально) могут принимать переменные
    (локальные, глобальные) в каждой процедуре.
    Всего у нас 9 переменных, все переменные имеют одинаковый тип - int(примем за мощность значений типа 2^32):
    <h> - общая(разделяемая переменная) для двух потоков;
    <f.x> - переменная x из процедуры f;
    <f.y> - переменная y из процедуры f;
    <g.x> - переменная x из процедуры g;
    <g.y> - переменная y из процедуры g;
    <f_a> - фактический параметр a процедуры f;
    <f_b> - фактический параметр b процедуры f;
    <g_a> - фактический параметр a процедуры g;
    <g_b> - фактический параметр b процедуры g;

        Potential_States = fLines * gLines * 2^(32 * 9)

    Считаем количество строк в каждой процедуре:
        fLines = 13
        gLines = 19

        Potential_States = fLines * gLines * 2^(32 * 9) = 13 * 19 * 2^(32 * 9) = 247 * 2^288.
        Оценим грубо сверху и снизу:
            1. Оценка сверху. PS = Potential_States.
                PS = 2.5*10^2 * (2^300/2^12 ) <= { 2^20 = 1048576 <= 11*10^5 } <= 2.5*10^2 * ( (2^20)^15/ 2^12) <=
                <= 2.5*10^2 * (11*10^5)^15 / 2^12 <={ 11 <= 12 } <= 2.5*10^2 * 4^15 * 3^15 * 10^75 / 2^12 <=
                <= { 3^15 = (3^2)^(15/2) <= 10^(15/2) = 10^(1/2)*10^7  }<=2.5 * 10^2 * 2^18 * 10^(1/2)*10^7 *
                * 10^75 <= 2.5 * 2^18 * 10^(1/2) * 10^84 <= {2^12 = 4096 <= 4.1*10^3 } <= 2.5 * 2^6 * 4.1 * 10^88 <=
                 <= 656 * 10^88 <= 7 * 10^90
            2. Оценка снизу.
                PS = 2.5*10^2 * (2^12)^24 >= { 2^12 = 4096} >= 2.5*10^2 * (4 * 10^3)^24 >=
                >= 2.5 * 4^24 * 10^74 >= { 4^24 = 2^48; 2^12 >= 4*10^3 } >= 2.5 * (4*10^3)^4 * 10^74 >=
                >= 2.5 * 16 * 10^86 = 4 * 10^87

===============================================================================

=================================Task_2========================================
Формулировка:
        Оценить размер множества достижимых состояний программы. Ответ обосновать.
    В обосновании описать множество достижимых состояний с помощью линейных
    равенств и неравенств на языке C.
Ответ:
        См. комментарии к строкам ниже.
        Для нахождения числа допустимых состояний нужно найти мощности множеств значений всех
        переменных, задействованных в программе, а также количество достижимых операторов процедур f и g.
        C(variable)[ сокр. от codomain - "область значений"]- количество различных допустимых значений, которые может
            принимать переменная variable.

            Feasible_States = Feasible_fLines * Feasible_gLines * C(h) * C(f.x) * C(f.y) * C(g.x) * C(g.y) * C(f_a) *
        * C(f_b) * C(g_a) * C(g_b)

            В первую очередь нужно определить внутри каждой процедуры, какие значения могут принимать переменные из
        другой процедуры, т.е. нужно просмотреть все операции присваивания в другой процедуре, которые касаются этой
        переменной. Это делается на первом проходе.
            На втором проходе сократить множества C(variable) для каждой variable. Сократить можно за счет недоступности
        некоторых строк, в состав которых входит операция присваивания.
            Последний шаг: взять в качестве C(variable) объедение всех множеств значений для соотв. переменной, полученных
        в каждой строке.

        Итог:
            Fesible_fLines = 13 - 4 = 9
            Fesible_gLines = 19 - 6 = 13
            C(h) = 3
            C(f.x) = 3
            C(f.y) = 2
            C(g.x) = 4
            C(g.y) = 3
            C(f_a) = 2^32
            C(f_b) = 2^32
            C(g_a) = 2^32
            C(g_b) = 2^32

            Feasible_States = 25272 * 2^128 = (2^14 + 2^13 + 2^9 + 2^7 + 2^5 + 2^4 + 2^3 )*2^128 =
            = 2^142 + 2^141 + 2^137 + 2^135 + 2^133 + 2^132 + 2^131

===============================================================================

int h;
void f (int a, int b) {
0:    int x, y; // h={#,1}, f.x=#, f.y=#, g.x={#,0,1,6}, g.y={#,7,10}, -2^31<=f_a<2^31, -2^31<=f_b<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31
                // операции g{h=4} g{y=2} g{y=5} g{y=9} недостижимы
1:    x = 7; // h={#,1}, f.x=#, f.y=#, g.x={#,0,1,6}, g.y={#,7,10}, -2^31<=f_a<2^31, -2^31<=f_b<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31
2:    y = 7; // h={#,1}, f.x=7, f.y=#, g.x={#,0,1,6}, g.y={#,7,10}, -2^31<=f_a<2^31, -2^31<=f_b<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31
3:    h = 4; // h={#,1}, f.x=7, f.y=7, g.x={#,0,1,6}, g.y={#,7,10}, -2^31<=f_a<2^31, -2^31<=f_b<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31

4:    if ( h < b ) { // h={1,4}, f.x=7, f.y=7, g.x={#,0,1,6}, g.y={#,7,10}, -2^31<=f_a<2^31, -2^31<=f_b<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31
                     // значение переменной h может поменять операция присваивания g{h=1}
5:        if ( h > 6 ) { // Два варианта
                         // (h={1} && 2<=f_b<=2^31), f.x=7, f.y=7, g.x={#,0,1,6}, g.y={#,7,10}, -2^31<=f_a<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31
                         // (h={4} && 5<=f_b<=2^31), f.x=7, f.y=7, g.x={#,0,1,6}, g.y={#,7,10}, -2^31<=f_a<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31
                         //условие в операторе if всегда ложно
6:            y = 10; // недостижимо, т.к. h всегда меньше 6
          }
7:        x = 2; // Два варианта
                 // (h={1} && 2<=f_b<=2^31), f.x=7, f.y=7, g.x={#,0,1,6}, g.y={#,7,10}, -2^31<=f_a<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31 ||
                 // (h={4} && 5<=f_b<=2^31), f.x=7, f.y=7, g.x={#,0,1,6}, g.y={#,7,10}, -2^31<=f_a<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31
      } else {
8:        if ( h > y ) { // Два варианта
                         // (h={1} && -2^31<=f_b<=1), f.x=7, f.y=7, g.x={#,0,1,6}, g.y={#,7,10}, -2^31<=f_a<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31 ||
                         // (h={4} && -2^31<=f_b<=4), f.x=7, f.y=7, g.x={#,0,1,6}, g.y={#,7,10}, -2^31<=f_a<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31
                         //условие в операторе if всегда ложно
9:            if ( h < a + x ) { // недостижимо, т.к. h={1,4} меньше f.y=7
10:                x = 1; // недостижимо
              }
11:           x = 4; // недостижимо
          }
      }
12:} // 4 Варианта
     // 2 варианта, если заходил в if
     // (h={1} && 2<=f_b<=2^31), f.x={2}, f.y=7, g.x={#,0,1,6}, g.y={#,7,10}, -2^31<=f_a<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31 ||
     // (h={4} && 5<=f_b<=2^31), f.x={2}, f.y=7, g.x={#,0,1,6}, g.y={#,7,10}, -2^31<=f_a<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31
     // 2 варианта, если не заходил а if
     // (h={1} && -2^31<=f_b<=1), f.x=7, f.y=7, g.x={#,0,1,6}, g.y={#,7,10}, -2^31<=f_a<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31 ||
     // (h={4} && -2^31<=f_b<=4), f.x=7, f.y=7, g.x={#,0,1,6}, g.y={#,7,10}, -2^31<=f_a<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31


void g (int a, int b) {
0:    int x, y; // h={#,4}, f.x={#,2,7}, f.y={#,7}, g.x=#, g.y=#, -2^31<=f_a<2^31, -2^31<=f_b<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31
                // операции f{y=10} f{x=1} f{x=4} недостижимы
1:    x = 1; // h={#,4}, f.x={#,2,7}, f.y={#,7}, g.x=#, g.y=#, -2^31<=f_a<2^31, -2^31<=f_b<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31
2:    y = 10; // h={#,4}, f.x={#,2,7}, f.y={#,7}, g.x=1, g.y=#, -2^31<=f_a<2^31, -2^31<=f_b<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31
3:    h = 1; // h={#,4}, f.x={#,2,7}, f.y={#,7}, g.x=1, g.y=10, -2^31<=f_a<2^31, -2^31<=f_b<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31

4:    if ( x < 10 ) { // h={1,4}, f.x={#,2,7}, f.y={#,7}, g.x=1, g.y=10, -2^31<=f_a<2^31, -2^31<=f_b<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31
                      // значение переменной может поменять операция присваивания f{h=4}
                      //условие в операторе if всегда истинно
5:        if ( h > y) { // h={1,4}, f.x={#,2,7}, f.y={#,7}, g.x=1, g.y=10, -2^31<=f_a<2^31, -2^31<=f_b<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31
                        //условие в операторе if всегда ложно
6:            y = 9; // недостижимо, т.к. g.y > h
          } else {
7:            x = 0; // h={1,4}, f.x={#,2,7}, f.y={#,7}, g.x=1, g.y=10, -2^31<=f_a<2^31, -2^31<=f_b<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31
          }
      }

8:    y = 7; // h={1,4}, f.x={#,2,7}, f.y={#,7}, g.x=0, g.y=10, -2^31<=f_a<2^31, -2^31<=f_b<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31
9:    x = 6; // h={1,4}, f.x={#,2,7}, f.y={#,7}, g.x=0, g.y=7, -2^31<=f_a<2^31, -2^31<=f_b<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31

10:   while (x < 9) { // h={1,4}, f.x={#,2,7}, f.y={#,7}, g.x=6, g.y=7, -2^31<=f_a<2^31, -2^31<=f_b<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31
                      // в цикл заходим всегда, т.к. (x=6) < 9
11:        if ( h > 0 ) // h={1,4}, f.x={#,2,7}, f.y={#,7}, g.x=6, g.y=7, -2^31<=f_a<2^31, -2^31<=f_b<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31
                        //условие в операторе if всегда истинно, следовательно, выполнится только одна итерация цикла
12:            break; // h={1,4}, f.x={#,2,7}, f.y={#,7}, g.x=6, g.y=7, -2^31<=f_a<2^31, -2^31<=f_b<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31

13:        if ( h > 6 ) { // недостижимо, т.к. значение переменной h всегда > 0 и строка 12 отработает всегда
14:            h = 4; // недостижимо
15:            if ( h > b + y ) { // недостижимо
16:                y = 2; // недостижимо
               }
17:            y = 5; // недостижимо
           }
      }
18:} // h={1,4}, f.x={#,2,7}, f.y={#,7}, g.x=6, g.y=7, -2^31<=f_a<2^31, -2^31<=f_b<2^31, -2^31<=g_a<2^31, -2^31<=g_b<2^31


=================================Task_3========================================
Формулировка:
        Написать программу на языке С, которая вычисляет и записывает в текстовой файл states.txt множество достижимых
    состояний заданной программы для заданных значений параметров функций, а также выводит в стандартный поток вывода
    количество достижимых состояний.
Ответ:
        Сначала немного модифицируем процедуры f и g, удалив из них недостижимые строки. Перенумеруем заново строки, но
    старую нумерацию сохраним для того, чтобы в файле с результатами в состояниях были старые номера.
    Решение в 421_chupakhin.cpp
    Строки процедуры f обозначаем нулями
    Строки процедуры g обозначаем единицами

int h;                              New Numeration
void f (int a, int b) {
0:    int x, y;                         0:
1:    x = 7;                            1:
2:    y = 7;                            2:
3:    h = 4;                            3:
4:    if ( h < b ) {                    4:
5:        if ( h > 6 ) {                5:
          }
7:        x = 2;                        6:
      } else {
8:        if ( h > y ) {                7:
          }
      }
12:}                                    8:

void g (int a, int b) {
0:    int x, y;                         0:
1:    x = 1;                            1:
2:    y = 10;                           2:
3:    h = 1;                            3:
4:    if ( x < 10 ) {                   4:
5:        if ( h > y) {                 5:
          } else {
7:            x = 0;                    6:
          }
      }
8:    y = 7;                            7:
9:    x = 6;                            8:

10:   while (x < 9) {                   9:
11:        if ( h > 0 )                 10:
12:            break;                   11:
           }
      }
18:}                                    12:




В задании были даны флаги для C-компилятора.
Поэтому я компилировал программу следующим образом
Makefile:
 all : prog clean
 
 prog: main.o
         g++ ./421_chupakhin.o -o ./prog
         
 main.o: ./421_chupakhin.cpp
         g++ -O2 -g -Wall -std=c++0x -c ./421_chupakhin.cpp
 clean:
         rm ./421_chupakhin.o

Makefile можно создать в той же папке, что и исходный текст программы.
После выполнить команду make -> исполняемый файл prog


===============================================================================
